
## 순회 뽑기

### 문제 설명

- n개의 단맛과 짠맛이 들어있는 재료를 받습니다. 단맛은 모든 재료를 더하고 짠맛은 모든 재료를 곱합니다. 단맛의 합과 짠맛의 곱의 차이가 가장 작은 수를 구하는 문제입니다.   <br>

### 자료 구조

- **n**
    - 타입 : 정수 
    - 저장 데이터 : 재료의 개수를 저장합니다.

- **tasty**
    - 타입 : 배열
    - 저장 데이터 : n개의 재료를 2차원 배열에 저장합니다.

- **ans**
    - 타입 : 배열
    - 저장 데이터 : 현재 뽑은 재료의 단맛의 합과 짠맛의 곱의 차를 저장합니다.

- **mul**
    - 타입 : 정수
    - 저장 데이터 : k개 뽑은 재료들의 짠맛의 곱을 저장합니다.
- **su**
    - 타입 : 정수 
    - 저장 데이터 : k개 뽑은 재료들의 단맛의 합을 저장합니다.
- **res**
    - 타입 : 배열
    - 저장 데이터 : k개의 재료를 뽑을 경우 뽑은 재료들을 저장합니다. 
### 풀이 과정

```txt
1. 재료의 개수 n을 입력받습니다.

2. 짠맛과 단맛을 배열에 저장합니다.

3. 재료 k 개를 순서 없이 뽑는 경우을 구하기 위해 DFS 함수를 수행합니다. DFS함수의 매개변수는 (깊이를 저장하는 L, 시작점, 현재뽑는개수, 결과를 담는 배열)입니다. 

4. 깊이 0에서 시작하여 깊이 L이 현재 뽑는 개수 k와 같아지면 뽑은 k개의 재료에 대해 단맛 합 짠맛 곱을 구합니다.

5. 4에서 구한 값의 차를 ans 배열에 붙이고 함수를 return합니다.

6. start 시작점 부터 모든 재료에 대해 for문을 수행합니다.

7. res[L]에 tasty[i]의 값을 저장하고 한번 뽑은 요소를 다시 뽑지 않기 때문에 다음 DFS 함수 start값을 i+1로 주고 다음 레벨에 대해 DFS를 수행해야하므로 L+1을 인자로 넘깁니다.  

8. 재료는 적어도 1개 사용해야하기 때문에 재료를 뽑는 경우는 k는 1 ~ n입니다.

9. 모든 경우의 차를 저장한 배열 ans에 대해 min을 수행하여 단맛과 짠맛의 차이가 가장 작은 경우를 프린트합니다.

```

### 코드 구현
- 사용 언어 : 파이썬

```python
#풀이 방법 1
n = int(input())
tasty = []
#풀이 방법 2
for _ in range(n):
    tasty.append(list(map(int,input().split())))
    
ans = []
#풀이 방법 3
def DFS(L,start,k,res):
    mul = 1
    su = 0
    #풀이 방법 4
    if L == k:
        for v1,v2 in res:
            mul *= v1
            su += v2
        #풀이 방법 5
        ans.append(abs(mul-su))
        return
    #풀이 방법 6
    for i in range(start,len(tasty)):
        #풀이 방법 7
        print(L)
        res[L] = tasty[i]
        DFS(L+1,i+1,k,res)
#풀이 방법 8
for k in range(1,n+1):
    res = [0 for _ in range(k)]
    DFS(0,0,k,res)
#풀이 방법 9
print(min(ans))
```



- 점수 : 100점 / 100점
